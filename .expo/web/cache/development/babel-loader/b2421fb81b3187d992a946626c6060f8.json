{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Ansari\\\\Documents\\\\Github\\\\Mercy-USA-App\\\\node_modules\\\\react-native-material-kit\\\\lib\\\\mdl\\\\Ripple.js\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectSpread2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { ViewPropTypes } from \"../utils\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport View from \"react-native-web/dist/exports/View\";\nvar UIManager = NativeModules.UIManager;\nimport * as MKPropTypes from \"../MKPropTypes\";\nimport MKTouchable from \"../internal/MKTouchable\";\n\nclass Ripple extends Component {\n  constructor(props) {\n    super(props);\n\n    this._onLayout = evt => {\n      this._onLayoutChange(evt.nativeEvent.layout);\n\n      if (this.props.onLayout) {\n        this.props.onLayout(evt);\n      }\n    };\n\n    this._onTouchEvent = evt => {\n      if (this.props.disabled === true) {\n        return;\n      }\n\n      switch (evt.type) {\n        case 'TOUCH_DOWN':\n          this._onPointerDown(evt);\n\n          break;\n\n        case 'TOUCH_UP':\n        case 'TOUCH_CANCEL':\n          this._onPointerUp();\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (this.props.onTouch) {\n        this.props.onTouch(evt);\n      }\n    };\n\n    this._animatedAlpha = new Animated.Value(0);\n    this._animatedRippleScale = new Animated.Value(0);\n    this.state = {\n      width: 1,\n      height: 1,\n      maskBorderRadius: 0,\n      shadowOffsetY: 1,\n      ripple: {\n        radii: 0,\n        dia: 0,\n        offset: {\n          top: 0,\n          left: 0\n        }\n      }\n    };\n  }\n\n  measure(cb) {\n    return this.refs.container && UIManager.measure(findNodeHandle(this.refs.container), cb);\n  }\n\n  _onLayoutChange(_ref) {\n    var {\n      width,\n      height\n    } = _ref;\n\n    if (width === this.state.width && height === this.state.height) {\n      return;\n    }\n\n    this.setState(_objectSpread2({\n      width,\n      height\n    }, this._calcMaskLayer(width, height)));\n  }\n\n  _calcMaskLayer(width, height) {\n    var maskRadiiPercent = this.props.maskBorderRadiusInPercent;\n    var maskBorderRadius = this.props.maskBorderRadius;\n\n    if (maskRadiiPercent) {\n      maskBorderRadius = Math.min(width, height) * maskRadiiPercent / 100;\n    }\n\n    return {\n      maskBorderRadius\n    };\n  }\n\n  _calcRippleLayer(x0, y0) {\n    var {\n      width,\n      height,\n      maskBorderRadius\n    } = this.state;\n    var {\n      maskBorderRadiusInPercent\n    } = this.props;\n    var radii;\n    var hotSpotX = x0;\n    var hotSpotY = y0;\n\n    if (this.props.rippleLocation === 'center') {\n      hotSpotX = width / 2;\n      hotSpotY = height / 2;\n    }\n\n    var offsetX = Math.max(hotSpotX, width - hotSpotX);\n    var offsetY = Math.max(hotSpotY, height - hotSpotY);\n\n    if (Platform.OS === 'android' && this.props.rippleLocation === 'center' && this.props.maskEnabled && maskBorderRadiusInPercent > 0) {\n      radii = maskBorderRadius;\n    } else {\n      radii = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n    }\n\n    return {\n      ripple: {\n        radii,\n        dia: radii * 2,\n        offset: {\n          top: hotSpotY - radii,\n          left: hotSpotX - radii\n        }\n      }\n    };\n  }\n\n  _onPointerDown(evt) {\n    this.setState(_objectSpread2({}, this._calcRippleLayer(evt.x, evt.y)));\n    this.showRipple();\n  }\n\n  _onPointerUp() {\n    this.hideRipple();\n  }\n\n  showRipple() {\n    this._animatedAlpha.setValue(1);\n\n    this._animatedRippleScale.setValue(0.3);\n\n    this._rippleAni = Animated.timing(this._animatedRippleScale, {\n      toValue: 1,\n      useNativeDriver: true,\n      duration: this.props.rippleDuration || 200\n    });\n\n    if (this.props.shadowAniEnabled) {\n      this.setState({\n        shadowOffsetY: 1.5\n      });\n    }\n\n    this._rippleAni.start(() => {\n      this._rippleAni = undefined;\n\n      if (this._pendingRippleAni) {\n        this._pendingRippleAni();\n      }\n    });\n  }\n\n  hideRipple() {\n    this._pendingRippleAni = () => {\n      Animated.timing(this._animatedAlpha, {\n        toValue: 0,\n        useNativeDriver: true,\n        duration: this.props.maskDuration || 200\n      }).start();\n\n      if (this.props.shadowAniEnabled) {\n        this.setState({\n          shadowOffsetY: 1\n        });\n      }\n\n      this._pendingRippleAni = undefined;\n    };\n\n    if (!this._rippleAni) {\n      this._pendingRippleAni();\n    }\n  }\n\n  render() {\n    var shadowStyle = {};\n\n    if (this.props.shadowAniEnabled) {\n      shadowStyle.shadowOffset = {\n        width: 0,\n        height: this.state.shadowOffsetY\n      };\n    }\n\n    var borderWidth = this.props.borderWidth || 0;\n    return React.createElement(MKTouchable, _extends({\n      ref: \"container\"\n    }, this.props, {\n      style: [this.props.style, shadowStyle],\n      onTouch: this._onTouchEvent,\n      onLayout: this._onLayout,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 223\n      }\n    }), this.props.children, React.createElement(Animated.View, {\n      ref: \"maskLayer\",\n      style: {\n        position: 'absolute',\n        backgroundColor: this.props.maskColor,\n        opacity: this._animatedAlpha,\n        top: -borderWidth,\n        left: -borderWidth,\n        width: this.state.width,\n        height: this.state.height,\n        borderRadius: this.state.maskBorderRadius,\n        overflow: this.props.maskEnabled ? 'hidden' : 'visible'\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 230\n      }\n    }, React.createElement(Animated.View, {\n      ref: \"rippleLayer\",\n      style: _objectSpread2({\n        backgroundColor: this.props.rippleColor,\n        width: this.state.ripple.dia,\n        height: this.state.ripple.dia\n      }, this.state.ripple.offset, {\n        borderRadius: this.state.ripple.radii,\n        transform: [{\n          scale: this._animatedRippleScale\n        }]\n      }),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 244\n      }\n    })));\n  }\n\n}\n\nRipple.propTypes = _objectSpread2({}, ViewPropTypes || View.propTypes, {\n  rippleColor: PropTypes.string,\n  rippleDuration: PropTypes.number,\n  rippleLocation: MKPropTypes.rippleLocation,\n  maskEnabled: PropTypes.bool,\n  maskColor: PropTypes.string,\n  maskBorderRadius: PropTypes.number,\n  maskBorderRadiusInPercent: PropTypes.number,\n  maskDuration: PropTypes.number,\n  shadowAniEnabled: PropTypes.bool,\n  onTouch: PropTypes.func,\n  onLayout: PropTypes.func\n});\nRipple.defaultProps = {\n  rippleColor: 'rgba(255,255,255,0.2)',\n  rippleDuration: 200,\n  rippleLocation: 'tapLocation',\n  maskEnabled: true,\n  maskColor: 'rgba(255,255,255,0.15)',\n  maskBorderRadius: 2,\n  maskDuration: 200,\n  shadowAniEnabled: true\n};\nmodule.exports = Ripple;","map":{"version":3,"sources":["C:\\Users\\Ansari\\Documents\\Github\\Mercy-USA-App\\node_modules\\react-native-material-kit\\lib\\mdl\\Ripple.js"],"names":["React","Component","PropTypes","ViewPropTypes","UIManager","NativeModules","MKPropTypes","MKTouchable","Ripple","constructor","props","_onLayout","evt","_onLayoutChange","nativeEvent","layout","onLayout","_onTouchEvent","disabled","type","_onPointerDown","_onPointerUp","onTouch","_animatedAlpha","Animated","Value","_animatedRippleScale","state","width","height","maskBorderRadius","shadowOffsetY","ripple","radii","dia","offset","top","left","measure","cb","refs","container","findNodeHandle","setState","_calcMaskLayer","maskRadiiPercent","maskBorderRadiusInPercent","Math","min","_calcRippleLayer","x0","y0","hotSpotX","hotSpotY","rippleLocation","offsetX","max","offsetY","Platform","OS","maskEnabled","sqrt","x","y","showRipple","hideRipple","setValue","_rippleAni","timing","toValue","useNativeDriver","duration","rippleDuration","shadowAniEnabled","start","undefined","_pendingRippleAni","maskDuration","render","shadowStyle","shadowOffset","borderWidth","style","children","position","backgroundColor","maskColor","opacity","borderRadius","overflow","rippleColor","transform","scale","propTypes","View","string","number","bool","func","defaultProps","module","exports"],"mappings":"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","sourcesContent":["//\n// Reusable Ripple layout\n//\n// - [Props](#props)\n// - [Defaults](#defaults)\n//\n// Created by ywu on 15/8/2.\n//\n\nimport React, {\n  Component,\n} from 'react';\nimport PropTypes from 'prop-types';\nimport { ViewPropTypes } from '../utils';\n\nimport {\n  Animated,\n  Platform,\n  NativeModules,\n  findNodeHandle,\n  View\n} from 'react-native';\nconst UIManager = NativeModules.UIManager;\n\nimport * as MKPropTypes from '../MKPropTypes';\nimport MKTouchable from '../internal/MKTouchable';\n\n//\n// ## <section id='Ripple'>Ripple</section>\n// Reusable `Ripple` effect.\n//\nclass Ripple extends Component {\n  constructor(props) {\n    super(props);\n    this._animatedAlpha = new Animated.Value(0);\n    this._animatedRippleScale = new Animated.Value(0);\n\n    // [Android] set initial size > 0 to avoid NPE\n    // at `ReactViewBackgroundDrawable.drawRoundedBackgroundWithBorders`\n    // @see https://github.com/facebook/react-native/issues/3069\n    this.state = {\n      width: 1,\n      height: 1,\n      maskBorderRadius: 0,\n      shadowOffsetY: 1,\n      ripple: { radii: 0, dia: 0, offset: { top: 0, left: 0 } },\n    };\n  }\n\n  // property initializers begin\n  _onLayout = (evt) => {\n    this._onLayoutChange(evt.nativeEvent.layout);\n\n    if (this.props.onLayout) {\n      this.props.onLayout(evt);\n    }\n  };\n\n  // Touch events handling\n  _onTouchEvent = (evt) => {\n    if (this.props.disabled === true) {\n      return;\n    }\n    \n    switch (evt.type) {\n      case 'TOUCH_DOWN':\n        this._onPointerDown(evt);\n        break;\n      case 'TOUCH_UP':\n      case 'TOUCH_CANCEL':\n        this._onPointerUp();\n        break;\n      default:\n        break;\n    }\n\n    if (this.props.onTouch) {\n      this.props.onTouch(evt);\n    }\n  };\n  // property initializers end\n\n  measure(cb) {\n    return this.refs.container && UIManager.measure(findNodeHandle(this.refs.container), cb);\n  }\n\n  _onLayoutChange({ width, height }) {\n    if (width === this.state.width && height === this.state.height) {\n      return;\n    }\n\n    this.setState({\n      width,\n      height,\n      ...this._calcMaskLayer(width, height),\n    });\n  }\n\n  // update Mask layer's dimen\n  _calcMaskLayer(width, height) {\n    const maskRadiiPercent = this.props.maskBorderRadiusInPercent;\n    let maskBorderRadius = this.props.maskBorderRadius;\n\n    if (maskRadiiPercent) {\n      maskBorderRadius = Math.min(width, height) * maskRadiiPercent / 100;\n    }\n\n    return { maskBorderRadius };\n  }\n\n  // update Ripple layer's dimen\n  _calcRippleLayer(x0, y0) {\n    const { width, height, maskBorderRadius } = this.state;\n    const { maskBorderRadiusInPercent } = this.props;\n    let radii;\n    let hotSpotX = x0;\n    let hotSpotY = y0;\n\n    if (this.props.rippleLocation === 'center') {\n      hotSpotX = width / 2;\n      hotSpotY = height / 2;\n    }\n    const offsetX = Math.max(hotSpotX, (width - hotSpotX));\n    const offsetY = Math.max(hotSpotY, (height - hotSpotY));\n\n    // FIXME Workaround for Android not respect `overflow`\n    // @see https://github.com/facebook/react-native/issues/3198\n    if (Platform.OS === 'android'\n        && this.props.rippleLocation === 'center'\n        && this.props.maskEnabled && maskBorderRadiusInPercent > 0) {\n      // limit ripple to the bounds of mask\n      radii = maskBorderRadius;\n    } else {\n      radii = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n    }\n\n    return {\n      ripple: {\n        radii,\n        dia: radii * 2,\n        offset: {\n          top: hotSpotY - radii,\n          left: hotSpotX - radii,\n        },\n      },\n    };\n  }\n\n  _onPointerDown(evt) {\n    this.setState({\n      ...this._calcRippleLayer(evt.x, evt.y),\n    });\n    this.showRipple();\n  }\n\n  _onPointerUp() {\n    this.hideRipple();\n  }\n\n  // Start the ripple effect\n  showRipple() {\n    this._animatedAlpha.setValue(1);\n    this._animatedRippleScale.setValue(0.3);\n\n    // scaling up the ripple layer\n    this._rippleAni = Animated.timing(this._animatedRippleScale, {\n      toValue: 1,\n      useNativeDriver: true,\n      duration: this.props.rippleDuration || 200,\n    });\n\n    // enlarge the shadow, if enabled\n    if (this.props.shadowAniEnabled) {\n      this.setState({ shadowOffsetY: 1.5 });\n    }\n\n    this._rippleAni.start(() => {\n      this._rippleAni = undefined;\n\n      // if any pending animation, do it\n      if (this._pendingRippleAni) {\n        this._pendingRippleAni();\n      }\n    });\n  }\n\n  // Stop the ripple effect\n  hideRipple() {\n    this._pendingRippleAni = () => {\n      // hide the ripple layer\n      Animated.timing(this._animatedAlpha, {\n        toValue: 0,\n        useNativeDriver: true,\n        duration: this.props.maskDuration || 200,\n      }).start();\n\n      // scale down the shadow\n      if (this.props.shadowAniEnabled) {\n        this.setState({ shadowOffsetY: 1 });\n      }\n\n      this._pendingRippleAni = undefined;\n    };\n\n    if (!this._rippleAni) {\n      // previous ripple animation is done, good to go\n      this._pendingRippleAni();\n    }\n  }\n\n  render() {\n    const shadowStyle = {};\n    if (this.props.shadowAniEnabled) {\n      shadowStyle.shadowOffset = {\n        width: 0,\n        height: this.state.shadowOffsetY,\n      };\n    }\n\n    const borderWidth = this.props.borderWidth || 0;\n\n    return (\n      <MKTouchable ref=\"container\"\n        {...this.props}\n        style={[this.props.style, shadowStyle]}\n        onTouch={this._onTouchEvent}\n        onLayout={this._onLayout}\n      >\n        {this.props.children}\n        <Animated.View\n          ref=\"maskLayer\"\n          style={{\n            position: 'absolute',\n            backgroundColor: this.props.maskColor,\n            opacity: this._animatedAlpha,\n            top: - borderWidth,\n            left: - borderWidth,\n            width: this.state.width,\n            height: this.state.height,\n            borderRadius: this.state.maskBorderRadius,\n            overflow: this.props.maskEnabled ? 'hidden' : 'visible',\n          }}\n        >\n          <Animated.View\n            ref=\"rippleLayer\"\n            style={{\n              // position: 'absolute',\n              backgroundColor: this.props.rippleColor,\n              width: this.state.ripple.dia,\n              height: this.state.ripple.dia,\n              ...this.state.ripple.offset,\n              borderRadius: this.state.ripple.radii,\n              transform: [\n                { scale: this._animatedRippleScale },\n              ],\n            }}\n          />\n        </Animated.View>\n      </MKTouchable>\n    );\n  }\n}\n\n// ## <section id='props'>Props</section>\nRipple.propTypes = {\n  // [RN.View Props](https://facebook.github.io/react-native/docs/view.html#props)...\n  ...(ViewPropTypes || View.propTypes),\n\n  // Color of the `Ripple` layer\n  rippleColor: PropTypes.string,\n\n  // Duration of the ripple effect, in milliseconds\n  rippleDuration: PropTypes.number,\n\n  // Hot-spot position of the ripple effect, [available values](../MKPropTypes.html#rippleLocation)\n  rippleLocation: MKPropTypes.rippleLocation,\n\n  // Whether a `Mask` layer should be used, to clip the ripple to the container’s bounds,\n  // default is `true`\n  maskEnabled: PropTypes.bool,\n\n  // Color of the `Mask` layer\n  maskColor: PropTypes.string,\n\n  // Border radius of the `Mask` layer\n  maskBorderRadius: PropTypes.number,\n\n  // Border radius of the `Mask` layer, in percentage (of min(width, height))\n  maskBorderRadiusInPercent: PropTypes.number,\n\n  // Duration of the mask effect (alpha), in milliseconds\n  maskDuration: PropTypes.number,\n\n  // Animating the shadow (on pressed/released) or not\n  shadowAniEnabled: PropTypes.bool,\n\n  // Touch events callback\n  onTouch: PropTypes.func,\n\n  onLayout: PropTypes.func,\n};\n\n// ## <section id='defaults'>Defaults</section>\nRipple.defaultProps = {\n  rippleColor: 'rgba(255,255,255,0.2)',\n  rippleDuration: 200,\n  rippleLocation: 'tapLocation',\n  maskEnabled: true,\n  maskColor: 'rgba(255,255,255,0.15)',\n  maskBorderRadius: 2,\n  maskDuration: 200,\n  shadowAniEnabled: true,\n};\n\n\n// ## Public interface\nmodule.exports = Ripple;\n"]},"metadata":{},"sourceType":"module"}
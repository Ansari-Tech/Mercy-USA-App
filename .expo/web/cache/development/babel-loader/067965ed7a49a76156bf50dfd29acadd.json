{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Ansari\\\\Documents\\\\Github\\\\Mercy-USA-App\\\\node_modules\\\\react-native-maps\\\\lib\\\\components\\\\Geojson.js\";\n\nfunction _objectSpread2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport Marker from \"./MapMarker\";\nimport Polyline from \"./MapPolyline\";\nimport Polygon from \"./MapPolygon\";\nexport var makeOverlays = features => {\n  var points = features.filter(f => f.geometry && (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint')).map(feature => makeCoordinates(feature).map(coordinates => makeOverlay(coordinates, feature))).reduce(flatten, []).map(overlay => _objectSpread2({}, overlay, {\n    type: 'point'\n  }));\n  var lines = features.filter(f => f.geometry && (f.geometry.type === 'LineString' || f.geometry.type === 'MultiLineString')).map(feature => makeCoordinates(feature).map(coordinates => makeOverlay(coordinates, feature))).reduce(flatten, []).map(overlay => _objectSpread2({}, overlay, {\n    type: 'polyline'\n  }));\n  var multipolygons = features.filter(f => f.geometry && f.geometry.type === 'MultiPolygon').map(feature => makeCoordinates(feature).map(coordinates => makeOverlay(coordinates, feature))).reduce(flatten, []);\n  var polygons = features.filter(f => f.geometry && f.geometry.type === 'Polygon').map(feature => makeOverlay(makeCoordinates(feature), feature)).reduce(flatten, []).concat(multipolygons).map(overlay => _objectSpread2({}, overlay, {\n    type: 'polygon'\n  }));\n  return points.concat(lines).concat(polygons);\n};\n\nvar flatten = (prev, curr) => prev.concat(curr);\n\nvar makeOverlay = (coordinates, feature) => {\n  var overlay = {\n    feature\n  };\n\n  if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n    overlay.coordinates = coordinates[0];\n\n    if (coordinates.length > 1) {\n      overlay.holes = coordinates.slice(1);\n    }\n  } else {\n    overlay.coordinates = coordinates;\n  }\n\n  return overlay;\n};\n\nvar makePoint = c => ({\n  latitude: c[1],\n  longitude: c[0]\n});\n\nvar makeLine = l => l.map(makePoint);\n\nvar makeCoordinates = feature => {\n  var g = feature.geometry;\n\n  if (g.type === 'Point') {\n    return [makePoint(g.coordinates)];\n  } else if (g.type === 'MultiPoint') {\n    return g.coordinates.map(makePoint);\n  } else if (g.type === 'LineString') {\n    return [makeLine(g.coordinates)];\n  } else if (g.type === 'MultiLineString') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'Polygon') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'MultiPolygon') {\n    return g.coordinates.map(p => p.map(makeLine));\n  } else {\n    return [];\n  }\n};\n\nvar Geojson = props => {\n  var overlays = makeOverlays(props.geojson.features);\n  return React.createElement(React.Fragment, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 101\n    }\n  }, overlays.map((overlay, index) => {\n    if (overlay.type === 'point') {\n      return React.createElement(Marker, {\n        key: index,\n        coordinate: overlay.coordinates,\n        pinColor: props.color,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 105\n        }\n      });\n    }\n\n    if (overlay.type === 'polygon') {\n      return React.createElement(Polygon, {\n        key: index,\n        coordinates: overlay.coordinates,\n        holes: overlay.holes,\n        strokeColor: props.strokeColor,\n        fillColor: props.fillColor,\n        strokeWidth: props.strokeWidth,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 114\n        }\n      });\n    }\n\n    if (overlay.type === 'polyline') {\n      return React.createElement(Polyline, {\n        key: index,\n        coordinates: overlay.coordinates,\n        strokeColor: props.strokeColor,\n        strokeWidth: props.strokeWidth,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 126\n        }\n      });\n    }\n  }));\n};\n\nexport default Geojson;","map":{"version":3,"sources":["C:\\Users\\Ansari\\Documents\\Github\\Mercy-USA-App\\node_modules\\react-native-maps\\lib\\components\\Geojson.js"],"names":["React","Marker","Polyline","Polygon","makeOverlays","features","points","filter","f","geometry","type","map","feature","makeCoordinates","coordinates","makeOverlay","reduce","flatten","overlay","lines","multipolygons","polygons","concat","prev","curr","length","holes","slice","makePoint","c","latitude","longitude","makeLine","l","g","p","Geojson","props","overlays","geojson","index","color","strokeColor","fillColor","strokeWidth"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport Marker from './MapMarker';\r\nimport Polyline from './MapPolyline';\r\nimport Polygon from './MapPolygon';\r\n\r\nexport const makeOverlays = features => {\r\n  const points = features\r\n    .filter(\r\n      f =>\r\n        f.geometry &&\r\n        (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint')\r\n    )\r\n    .map(feature =>\r\n      makeCoordinates(feature).map(coordinates =>\r\n        makeOverlay(coordinates, feature)\r\n      )\r\n    )\r\n    .reduce(flatten, [])\r\n    .map(overlay => ({ ...overlay, type: 'point' }));\r\n\r\n  const lines = features\r\n    .filter(\r\n      f =>\r\n        f.geometry &&\r\n        (f.geometry.type === 'LineString' ||\r\n          f.geometry.type === 'MultiLineString')\r\n    )\r\n    .map(feature =>\r\n      makeCoordinates(feature).map(coordinates =>\r\n        makeOverlay(coordinates, feature)\r\n      )\r\n    )\r\n    .reduce(flatten, [])\r\n    .map(overlay => ({ ...overlay, type: 'polyline' }));\r\n\r\n  const multipolygons = features\r\n    .filter(f => f.geometry && f.geometry.type === 'MultiPolygon')\r\n    .map(feature =>\r\n      makeCoordinates(feature).map(coordinates =>\r\n        makeOverlay(coordinates, feature)\r\n      )\r\n    )\r\n    .reduce(flatten, []);\r\n\r\n  const polygons = features\r\n    .filter(f => f.geometry && f.geometry.type === 'Polygon')\r\n    .map(feature => makeOverlay(makeCoordinates(feature), feature))\r\n    .reduce(flatten, [])\r\n    .concat(multipolygons)\r\n    .map(overlay => ({ ...overlay, type: 'polygon' }));\r\n\r\n  return points.concat(lines).concat(polygons);\r\n};\r\n\r\nconst flatten = (prev, curr) => prev.concat(curr);\r\n\r\nconst makeOverlay = (coordinates, feature) => {\r\n  let overlay = {\r\n    feature,\r\n  };\r\n  if (\r\n    feature.geometry.type === 'Polygon' ||\r\n    feature.geometry.type === 'MultiPolygon'\r\n  ) {\r\n    overlay.coordinates = coordinates[0];\r\n    if (coordinates.length > 1) {\r\n      overlay.holes = coordinates.slice(1);\r\n    }\r\n  } else {\r\n    overlay.coordinates = coordinates;\r\n  }\r\n  return overlay;\r\n};\r\n\r\nconst makePoint = c => ({ latitude: c[1], longitude: c[0] });\r\n\r\nconst makeLine = l => l.map(makePoint);\r\n\r\nconst makeCoordinates = feature => {\r\n  const g = feature.geometry;\r\n  if (g.type === 'Point') {\r\n    return [makePoint(g.coordinates)];\r\n  } else if (g.type === 'MultiPoint') {\r\n    return g.coordinates.map(makePoint);\r\n  } else if (g.type === 'LineString') {\r\n    return [makeLine(g.coordinates)];\r\n  } else if (g.type === 'MultiLineString') {\r\n    return g.coordinates.map(makeLine);\r\n  } else if (g.type === 'Polygon') {\r\n    return g.coordinates.map(makeLine);\r\n  } else if (g.type === 'MultiPolygon') {\r\n    return g.coordinates.map(p => p.map(makeLine));\r\n  } else {\r\n    return [];\r\n  }\r\n};\r\n\r\nconst Geojson = props => {\r\n  const overlays = makeOverlays(props.geojson.features);\r\n  return (\r\n    <React.Fragment>\r\n      {overlays.map((overlay, index) => {\r\n        if (overlay.type === 'point') {\r\n          return (\r\n            <Marker\r\n              key={index}\r\n              coordinate={overlay.coordinates}\r\n              pinColor={props.color}\r\n            />\r\n          );\r\n        }\r\n        if (overlay.type === 'polygon') {\r\n          return (\r\n            <Polygon\r\n              key={index}\r\n              coordinates={overlay.coordinates}\r\n              holes={overlay.holes}\r\n              strokeColor={props.strokeColor}\r\n              fillColor={props.fillColor}\r\n              strokeWidth={props.strokeWidth}\r\n            />\r\n          );\r\n        }\r\n        if (overlay.type === 'polyline') {\r\n          return (\r\n            <Polyline\r\n              key={index}\r\n              coordinates={overlay.coordinates}\r\n              strokeColor={props.strokeColor}\r\n              strokeWidth={props.strokeWidth}\r\n            />\r\n          );\r\n        }\r\n      })}\r\n    </React.Fragment>\r\n  );\r\n};\r\n\r\nexport default Geojson;\r\n"]},"metadata":{},"sourceType":"module"}